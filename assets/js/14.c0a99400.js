(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{367:function(t,a,r){"use strict";r.r(a);var e=r(25),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"装饰者模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#装饰者模式"}},[t._v("🎋")]),t._v(" 装饰者模式")]),t._v(" "),r("p",[t._v("目的：对一个类添加新的功能，但不改变原来的类。")]),t._v(" "),r("p",[t._v("实现：通过创建一个装饰类对原有类进行包装（组合），进而添加新的功能。")]),t._v(" "),r("p",[t._v("优点：使用组合和面向抽象原则更灵活，可以动态扩展。")]),t._v(" "),r("h2",{attrs:{id:"实现类图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现类图"}},[t._v("🎋")]),t._v(" 实现类图")]),t._v(" "),r("p",[t._v("Java IO 流类库是经典的装饰者模式的实现，这里直接给出 Java IO 流的一个类图：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://pycrab.github.io/KeepJava/assets/media/idea-patterns-decorator1.png",alt:"IO 流装饰者模式类图.png"}})]),t._v(" "),r("p",[t._v("装饰者模式的要点：")]),t._v(" "),r("ul",[r("li",[t._v("面向抽象\n"),r("ul",[r("li",[t._v("被装饰类（FileInputStream）和抽象装饰类（FilterInputStream）都继承抽象类（InputStream）或者实现接口")]),t._v(" "),r("li",[t._v("具体装饰类（BufferedInputStream）继承抽象装饰类（FilterInputStream）")])])]),t._v(" "),r("li",[t._v("使用组合\n"),r("ul",[r("li",[t._v("抽象装饰类持有被装饰类的对象引用")])])])]),t._v(" "),r("h2",{attrs:{id:"一知半解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一知半解"}},[t._v("🎋")]),t._v(" 一知半解")]),t._v(" "),r("h3",{attrs:{id:"为什么不使用继承扩展"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么不使用继承扩展"}},[t._v("🎋")]),t._v(" 为什么不使用继承扩展？")]),t._v(" "),r("p",[t._v("如果仅仅是对一个类进行扩展，可以使用继承；但是如果对多个类进行同样的扩展，再使用继承就会产生大量类似的子类，这时就应该使用装饰者模式进行组合。")]),t._v(" "),r("h3",{attrs:{id:"为什么要有抽象装饰类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有抽象装饰类"}},[t._v("🎋")]),t._v(" 为什么要有抽象装饰类？")]),t._v(" "),r("p",[t._v("面向抽象的原则，封装公共的部分（如 Java IO 中释放系统资源的 close() 方法）；提供需要被装饰的功能，由具体装饰类去实现。")])])}),[],!1,null,null,null);a.default=s.exports}}]);