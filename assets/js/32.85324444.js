(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{385:function(t,a,s){"use strict";s.r(a);var e=s(25),o=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("绝大多数 IO 操作都涉及数据在内核空间和用户空间之间的拷贝，这个过程是由操作系统底层调用来完成。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("同步与异步，阻塞与非阻塞")]),t._v(" "),s("p",[t._v("传统的 IO 读操作主要分为两步：1、发起 read() 请求直到操作系统内核准备好数据；2、数据从内核空间拷贝到用户空间。")]),t._v(" "),s("p",[t._v("同步与异步指的是第一步数据准备好后，第二步读操作是同步还是异步。")]),t._v(" "),s("p",[t._v("阻塞与非阻塞指的是执行 IO 的线程发起读请求操作后，当前线程继续执行其它操作还是阻塞等待返回。")])]),t._v(" "),s("p",[t._v("据此操作系统实现了以下五种 IO 模型：")]),t._v(" "),s("h2",{attrs:{id:"bio-阻塞-io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bio-阻塞-io"}},[t._v("🎋")]),t._v(" BIO : 阻塞 IO")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://pycrab.github.io/KeepJava/assets/media/jdk-io-model1.png",alt:"阻塞 IO 模型.png"}})]),t._v(" "),s("p",[t._v("阻塞 IO 模型指的是，应用进程发起 recvfrom 系统调用后，在数据准备阶段和数据拷贝阶段都是阻塞的。")]),t._v(" "),s("h2",{attrs:{id:"nio-非阻塞-io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nio-非阻塞-io"}},[t._v("🎋")]),t._v(" NIO : 非阻塞 IO")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://pycrab.github.io/KeepJava/assets/media/jdk-io-model2.png",alt:"非阻塞 IO 模型.png"}})]),t._v(" "),s("p",[t._v("非阻塞 IO 模型指的是，应用进程发起 recvfrom 系统调用后，内核会立即返回 EWOULDBLOCK，之后应用进程会不断轮询调用 recvfrom，直到状态不为 EWOULDBLOCK 之后，表示数据已经准备好了，然后进行数据拷贝，此阶段数据拷贝仍是阻塞的。")]),t._v(" "),s("h2",{attrs:{id:"io-多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#io-多路复用"}},[t._v("🎋")]),t._v(" IO 多路复用")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://pycrab.github.io/KeepJava/assets/media/jdk-io-model3.png",alt:"IO 多路复用模型.png"}})]),t._v(" "),s("p",[t._v("多路复用模型指的是，应用进程首先发起 select/poll/epoll 系统调用，将请求注册到一个单独线程中，由这个线程去轮询内核是否准备好数据，准备好之后回调应用进程，应用进程发起 recvfrom 系统调用来进行数据拷贝。该模型轮询的线程和数据拷贝阶段是阻塞的（epoll 系统调用通过事件驱动的方式而不是轮询来判断数据是否准备好，性能更高）。")]),t._v(" "),s("h2",{attrs:{id:"信号驱动-io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#信号驱动-io"}},[t._v("🎋")]),t._v(" 信号驱动 IO")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://pycrab.github.io/KeepJava/assets/media/jdk-io-model4.png",alt:"信号驱动 IO 模型.png"}})]),t._v(" "),s("p",[t._v("信号驱动 IO 模型指的是，应用进程首先发起 sigaction 系统调用注册一个信号处理函数，当数据准备好后会生成一个信号通知应用进程发起 recvfrom 调用拷贝数据，拷贝数据阶段应用进程仍是阻塞的。")]),t._v(" "),s("h2",{attrs:{id:"aio-异步-io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aio-异步-io"}},[t._v("🎋")]),t._v(" AIO : 异步 IO")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://pycrab.github.io/KeepJava/assets/media/jdk-io-model5.png",alt:"异步 IO 模型.png"}})]),t._v(" "),s("p",[t._v("异步 IO 模型真正实现了异步非阻塞，应用进程告知内核启动一个操作，内核准备好数据后自动进行数据拷贝，拷贝完成后通知应用进程。")]),t._v(" "),s("h2",{attrs:{id:"对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[t._v("🎋")]),t._v(" 对比")]),t._v(" "),s("blockquote",[s("p",[t._v("前四种 IO 模型都是同步的，因为在从内核空间拷贝数据到用户空间的过程中应用进程都是阻塞的，只有异步 IO 模型是异步非阻塞的。")])]),t._v(" "),s("blockquote",[s("p",[t._v("IO 多路复用类似于非阻塞 IO，只是新启动了一个线程去轮询，解放了应用线程，适用于处理大量线程连接。")])]),t._v(" "),s("blockquote",[s("p",[t._v("信号驱动 IO 模型是告知应用进程数据已经准备好了，异步 IO 模型是告知应用进程数据已经拷贝完成了。")])]),t._v(" "),s("div",{staticClass:"custom-block danger"},[s("p",{staticClass:"custom-block-title"},[t._v("参考文献")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("《Netty 权威指南》这本书真心不错，推荐阅读。本文图片来源此书。")])]),t._v(" "),s("li",[s("p",[t._v("知乎 Wang Young’s Hub "),s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/161357177",target:"_blank",rel:"noopener noreferrer"}},[t._v("IO模型和基于事件驱动的IO多路复用模式"),s("OutboundLink")],1)])])])])])}),[],!1,null,null,null);a.default=o.exports}}]);